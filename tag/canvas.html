<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>carlcarl's blog - canvas</title>
        <link rel="stylesheet" href="/theme/css/main.css" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">carlcarl's blog </a></h1>
                <nav><ul>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/1023/html5-canvas-double-buffering/">html5 canvas double buffering</a></h1>
<footer class="post-info">
        <abbr class="published" title="2013-06-16T19:25:00">
                日 16 6月 2013
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="/author/carlcarl.html">carlcarl</a>
        </address>
<p>In <a href="/category/js.html">js</a>. </p>
<p>tags: <a href="/tag/canvas.html">canvas</a><a href="/tag/html5.html">html5</a></p>
</footer><!-- /.post-info --><p>因為之前寫 java 的經驗，讓我以為在 html5 的 canvas 上也要自己實作 double
buffering，但是在我後來實作後發現，好像哪裡怪怪的，因為其實原本就沒有在閃的感覺了，所以加了
double buffering 好像也沒啥差，重點是 performance 下降很多......。</p>
<!--more-->

<p>後來花了一些時間找資料，我得到的結論－是大部分的情況，不需要自己做
double buffering，因為瀏覽器會很聰明的幫你做。但是它怎麼判斷什麼時候該把
buffer 的部分 render 上去呢？以下是我的鍵盤猜測：</p>
<p>因為現在大多數的螢幕更新頻率都是 60Hz，也就是說大概每 16 ms
就會刷新一次螢幕，而瀏覽器本身在刷新的頻率可能也會接近這個時間，但是有沒有比較高就不知道了，因為你所看到的可能會被你螢幕的更新頻率所限制，就算瀏覽器刷新頻率是
1000Hz，反正一般的銀幕也看不出來:P。</p>
<p>以一個簡單的例子來實驗，假如我在一開始把一個方形塗上顏色然後 clear
掉，等一段時間後再塗上顏色，間隔如果設 10ms
的話，在我的螢幕上就看不到被清空的那段畫面；又假如我設成
20ms，就會看到被刷空白的那段畫面，也就是俗稱的「畫面在閃」，我在這邊實驗的結果是
12ms 就會有閃的感覺，也許是因為程式執行的
delay。然後瀏覽器應該也不會傻傻的即使你什麼都不做也一直重複 render
上去，而是在上次 render
後這段時間，假如有做一些畫面上的操作，才會把畫面再 render
上去，這樣感覺比較合理。</p>
<p>也就是說，如果你的圖形可以在 1x ms 畫完的話，就不需要做 double
buffering；但是如果你的圖形很複雜，你畫這個圖形需要 100ms，又是直接畫在
canvas
上，那可能就會出現半完成的圖形（我說可能的原因是不知道瀏覽器會不會自己做
optimization，等到一個 function 裡的事情都做完再一起
render，因為我之前的實驗使用 <code>setTimeout</code> 來做，有可能不符合 browser
optimize 的策略？），在這種情況下就有可能會考慮做 double buffering
。另外還有一種情況就是像 <a href="http://www.html5rocks.com/en/tutorials/canvas/performance/">這篇</a> 所提到的，可以省略掉每次都要重新
render 複雜圖形的步驟，效能上會好很多。</p>
<p>如果真的要做 double buffering 的話，
有些簡單的方法，我之前用的方法是用另外生一個 canvas，在上面畫完之後再用
drawImage 把 buffering canvas 畫到 display 用的 canvas
就好了，或是這邊還有 <a href="http://stackoverflow.com/questions/2795269/does-html5-canvas-support-double-buffering">一個簡單的方法</a> 可以參考看看。</p>
<p>參考資料:<br />
<a href="http://stackoverflow.com/questions/11777483/do-we-need-to-implement-double-buffering-ourselves-with-canvas">Do we need to implement double buffering ourselves with \&lt;canvas>?</a><br />
<a href="http://www.mail-archive.com/whatwg@lists.whatwg.org/msg19969.html">Re: [whatwg] Canvas size and double buffering.</a>  </p>                </article>
            </aside><!-- /#featured -->
                <section id="content" class="body">
                    <h1>Other articles</h1>
                    <hr />
                    <ol id="posts-list" class="hfeed">

            <li><article class="hentry">
                <header>
                    <h1><a href="/606/test-kineticjs-apply-canvas/" rel="bookmark"
                           title="Permalink to Test KineticJS apply canvas">Test KineticJS apply canvas</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2012-09-04T01:54:00">
                二 04 9月 2012
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="/author/carlcarl.html">carlcarl</a>
        </address>
<p>In <a href="/category/js.html">js</a>. </p>
<p>tags: <a href="/tag/canvas.html">canvas</a><a href="/tag/kineticjs.html">kineticjs</a></p>
</footer><!-- /.post-info -->                <p>寫起來跟以前寫 Java 作類似東西的感覺很像，東西基本上都已經用物件包好，然後還有提供 layer
讓你可以很方便的在不同 layer 放你要的物件。<br />
<!--more--><br />
我嘗試把我原本<a href="https://github.com/carlcarl/CaGo/blob/master/js/cago.js">播放棋譜</a>的 canvas 改成套用 KineticJS，不過後來發現，因為我的 canvas
操作沒很複雜，所以真的是太大材小用了...。</p>
<p>以可讀性來講，因為我大部分畫 canvas 都是放在一個 function 裡，大致用幾個註解分幾個段落，其實就知道各部份的流程，換成物件的方式後，整個 function 感覺並沒有更好讀，而且程式沒有比較短=.=。</p>
<p>然後我用一個固定的測試流程來作測試(這個流程不包括前面的 js file loading，是讀完後才開始作操作測試)，測試的結果原本是 200ms，換成 KineticJS 之後是 800ms，整個很不划算 ~.~。</p>
<p>雖然 KineticJS 有提供 layer ...</p>
                <a class="readmore" href="/606/test-kineticjs-apply-canvas/">read more</a>
                </div><!-- /.entry-content -->
            </article></li>
            </ol><!-- /#posts-list -->
<p class="paginator">
    Page 1 / 1
</p>
            </section><!-- /#content -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>blogroll</h2>
                        <ul>
                            <li><a href="http://getpelican.com/">Pelican</a></li>
                            <li><a href="http://python.org/">Python.org</a></li>
                            <li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>